#ifndef T_DISTRIBUTION_HPP
#define T_DISTRIBUTION_HPP

#include <cmath>
#include <algorithm>
#include <limits>

// All codes below are generated by ChatGPT 

namespace t_distribution {

constexpr double EPS = 1e-15;
constexpr int MAX_ITER = 10000;

// PDF of t-distribution
inline double pdf(double t, double nu) {
    if (nu <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    double coef = std::tgamma((nu + 1.0) / 2.0) / 
                  (std::sqrt(nu * M_PI) * std::tgamma(nu / 2.0));
    return coef * std::pow(1.0 + t * t / nu, -(nu + 1.0) / 2.0);
}

// Continued fraction for incomplete beta
inline double betacf(double a, double b, double x) {
    double qab = a + b;
    double qap = a + 1.0;
    double qam = a - 1.0;
    double c = 1.0;
    double d = 1.0 - qab * x / qap;
    if (std::fabs(d) < EPS) d = EPS;
    d = 1.0 / d;
    double h = d;

    for (int m = 1; m <= MAX_ITER; ++m) {
        int m2 = 2 * m;
        double aa = m * (b - m) * x / ((qam + m2) * (a + m2));
        d = 1.0 + aa * d;
        if (std::fabs(d) < EPS) d = EPS;
        c = 1.0 + aa / c;
        if (std::fabs(c) < EPS) c = EPS;
        d = 1.0 / d;
        h *= d * c;

        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
        d = 1.0 + aa * d;
        if (std::fabs(d) < EPS) d = EPS;
        c = 1.0 + aa / c;
        if (std::fabs(c) < EPS) c = EPS;
        d = 1.0 / d;
        double del = d * c;
        h *= del;
        if (std::fabs(del - 1.0) < EPS) break;
    }

    return h;
}

// Regularized incomplete beta function I_x(a,b)
inline double incbeta(double x, double a, double b) {
    if (x < 0.0 || x > 1.0) return std::numeric_limits<double>::quiet_NaN();
    if (x == 0.0) return 0.0;
    if (x == 1.0) return 1.0;

    double ln_bt = std::lgamma(a + b) - std::lgamma(a) - std::lgamma(b)
                   + a * std::log(x) + b * std::log(1.0 - x);
    double bt = std::exp(ln_bt);

    if (x < (a + 1.0) / (a + b + 2.0))
        return bt * betacf(a, b, x) / a;
    else
        return 1.0 - bt * betacf(b, a, 1.0 - x) / b;
}

// CDF of t-distribution
inline double cdf(double t, double nu) {
    if (nu <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    if (t == 0.0) return 0.5;

    double x = nu / (t * t + nu);
    double ib = incbeta(x, nu / 2.0, 0.5);
    return (t > 0.0) ? 1.0 - 0.5 * ib : 0.5 * ib;
}

// Complementary CDF (P(T > t))
inline double ccdf(double t, double nu) {
    return 1.0 - cdf(t, nu);
}

// Two-tailed p-value
inline double two_tailed_p(double t, double nu) {
    double c = cdf(t, nu);
    double cc = 1.0 - c;
    return 2.0 * std::min(c, cc);
}

// PDF of chi-square distribution
inline double chi2_pdf(double x, double k) {
    if (x < 0.0 || k <= 0.0) return 0.0;
    double coef = 1.0 / (std::pow(2.0, k/2.0) * std::tgamma(k/2.0));
    return coef * std::pow(x, k/2.0 - 1.0) * std::exp(-x/2.0);
}

// Regularized lower incomplete gamma function P(a, x)
inline double gammainc_lower(double a, double x) {
    if (x < 0.0 || a <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    if (x == 0.0) return 0.0;
    double sum = 1.0 / a;
    double term = 1.0 / a;
    for (int n = 1; n < MAX_ITER; ++n) {
        term *= x / (a + n);
        sum += term;
        if (term < EPS) break;
    }
    return sum * std::exp(-x + a * std::log(x) - std::lgamma(a));
}

// CDF of chi-square distribution
inline double chi2_cdf(double x, double k) {
    if (x < 0.0 || k <= 0.0) return 0.0;
    return gammainc_lower(k / 2.0, x / 2.0);
}

// CCDF
inline double chi2_ccdf(double x, double k) {
    return 1.0 - chi2_cdf(x, k);
}

// Upper-tail probability (for p-value)
inline double chi2_pvalue(double x, double k) {
    return chi2_ccdf(x, k);
}

} // namespace t_distribution

#endif // T_DISTRIBUTION_HPP


