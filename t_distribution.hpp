#ifndef T_DISTRIBUTION_HPP
#define T_DISTRIBUTION_HPP

#include <cmath>
#include <algorithm>
#include <limits>

// All codes below are generated by ChatGPT 

namespace t_distribution {

constexpr double EPS = 1e-15;
constexpr int MAX_ITER = 10000;

// PDF of t-distribution
inline double pdf(double t, double nu) {
    if (nu <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    double coef = std::tgamma((nu + 1.0) / 2.0) / 
                  (std::sqrt(nu * M_PI) * std::tgamma(nu / 2.0));
    return coef * std::pow(1.0 + t * t / nu, -(nu + 1.0) / 2.0);
}

// Continued fraction for incomplete beta
inline double betacf(double a, double b, double x) {
    double qab = a + b;
    double qap = a + 1.0;
    double qam = a - 1.0;
    double c = 1.0;
    double d = 1.0 - qab * x / qap;
    if (std::fabs(d) < EPS) d = EPS;
    d = 1.0 / d;
    double h = d;

    for (int m = 1; m <= MAX_ITER; ++m) {
        int m2 = 2 * m;
        double aa = m * (b - m) * x / ((qam + m2) * (a + m2));
        d = 1.0 + aa * d;
        if (std::fabs(d) < EPS) d = EPS;
        c = 1.0 + aa / c;
        if (std::fabs(c) < EPS) c = EPS;
        d = 1.0 / d;
        h *= d * c;

        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
        d = 1.0 + aa * d;
        if (std::fabs(d) < EPS) d = EPS;
        c = 1.0 + aa / c;
        if (std::fabs(c) < EPS) c = EPS;
        d = 1.0 / d;
        double del = d * c;
        h *= del;
        if (std::fabs(del - 1.0) < EPS) break;
    }

    return h;
}

// Regularized incomplete beta function I_x(a,b)
inline double incbeta(double x, double a, double b) {
    if (x < 0.0 || x > 1.0) return std::numeric_limits<double>::quiet_NaN();
    if (x == 0.0) return 0.0;
    if (x == 1.0) return 1.0;

    double ln_bt = std::lgamma(a + b) - std::lgamma(a) - std::lgamma(b)
                   + a * std::log(x) + b * std::log(1.0 - x);
    double bt = std::exp(ln_bt);

    if (x < (a + 1.0) / (a + b + 2.0))
        return bt * betacf(a, b, x) / a;
    else
        return 1.0 - bt * betacf(b, a, 1.0 - x) / b;
}

// CDF of t-distribution
inline double cdf(double t, double nu) {
    if (nu <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    if (t == 0.0) return 0.5;

    double x = nu / (t * t + nu);
    double ib = incbeta(x, nu / 2.0, 0.5);
    return (t > 0.0) ? 1.0 - 0.5 * ib : 0.5 * ib;
}

// Two-tailed p-value
inline double t_upper_tail(double t, double nu) {
    if (nu <= 0.0) return std::numeric_limits<double>::quiet_NaN();
    if (t < 0.0) return 1.0 - t_upper_tail(-t, nu);

    double x = nu / (t * t + nu);
    return 0.5 * incbeta(x, nu / 2.0, 0.5);
}

inline double two_tailed_p(double t, double nu) {
    return 2.0 * t_upper_tail(std::fabs(t), nu);
}

inline double gammainc_upper(double a, double x) {
    if (x < 0.0 || a <= 0.0) return std::numeric_limits<double>::quiet_NaN();

    double b = x + 1.0 - a;
    double c = 1.0 / 1e-30;
    double d = 1.0 / b;
    double h = d;

    for (int i = 1; i < MAX_ITER; ++i) {
        double an = -i * (i - a);
        b += 2.0;
        d = an * d + b;
        if (std::fabs(d) < 1e-30) d = 1e-30;
        c = b + an / c;
        if (std::fabs(c) < 1e-30) c = 1e-30;
        d = 1.0 / d;
        double delta = d * c;
        h *= delta;
        if (std::fabs(delta - 1.0) < EPS) break;
    }

    return std::exp(-x + a * std::log(x) - std::lgamma(a)) * h;
}

inline double chi2_pvalue(double x, double k) {
    if (x < 0.0 || k <= 0.0) return 1.0;
    return gammainc_upper(k / 2.0, x / 2.0);
}

} // namespace t_distribution

#endif // T_DISTRIBUTION_HPP


